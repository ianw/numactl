.\" Copyright 2003,2004 Andi Kleen, SuSE Labs.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.TH NUMA 3 "May 2004" "SuSE Labs" "Linux Programmer's Manual"
.SH NAME
numa \- NUMA policy library
.SH SYNOPSIS
.B #include <numa.h>
.sp
.B cc ... \-lnuma
.sp
.B int numa_available(void);
.sp
.B int numa_max_node(void);
.br
.B int numa_preferred(void);
.br
.BI "long numa_node_size(int " node ", long *" freep );
.br
.BI "long long numa_node_size64(int " node ", long long *" freep );
.sp
.BI "nodemask_t " numa_all_nodes ;
.br
.BI "nodemask_t " numa_no_nodes ;
.br
.BI "int numa_node_to_cpus(int " node ", unsigned long *" buffer ", int " bufferlen );
.sp
.br
.BI "void nodemask_zero(nodemask_t *" mask );
.br
.BI "void nodemask_set(nodemask_t *" mask ", int " node );
.br
.BI "void nodemask_clr(nodemask_t *" mask ", int " node );
.br
.BI "int nodemask_isset(const nodemask_t *" mask ", int " node );
.br
.BI "int nodemask_equal(const nodemask_t *" a ", const nodemask_t " b );
.sp
.BI "void numa_set_interleave_mask(nodemask_t *" nodemask );
.br
.B nodemask_t numa_get_interleave_mask(void);
.br
.BI "void numa_bind(nodemask_t *" nodemask );
.br
.BI "void numa_set_preferred(int " node );
.br
.BI "void numa_set_localalloc(void);
.br
.BI "void numa_set_membind(nodemask_t *" nodemask );
.br
.B nodemask_t numa_get_membind(void);
.sp
.BI "void *numa_alloc_interleaved_subset(size_t " size ", nodemask_t *" nodemask );
.br
.BI "void *numa_alloc_interleaved(size_t " size );
.br
.BI "void *numa_alloc_onnode(size_t " size ", int " node );
.br
.BI "void *numa_alloc_local(size_t " size );
.br
.BI "void *numa_alloc(size_t " size );
.br
.BI "void numa_free(void *" start ", size_t " size );
.sp
.BI "int numa_run_on_node_mask(nodemask_t *" nodemask );
.br
.BI "int numa_run_on_node(int " node );
.br
.B nodemask_t numa_get_run_node_mask(void);
.sp
.BI "void numa_interleave_memory(void *" start ", size_t " size ", nodemask_t *" nodemask );
.br
.BI "void numa_tonode_memory(void *" start ", size_t " size ", int " node );
.br
.BI "void numa_tonodemask_memory(void *" start ", size_t " size ", nodemask_t *" nodemask );
.br
.BI "void numa_setlocal_memory(void *" start ", size_t " size );
.br
.BI "void numa_police_memory(void *" start ", size_t " size );
.br
.BI "int numa_distance(int " node1 ", int " node2 );
.br
.BI "void numa_set_bind_policy(int " strict );
.br
.BI "void numa_set_strict(int " strict );
.br
.BI "void numa_error(char *" where );
.br
.BI "void numa_warn(int " number ", char *" where ", ...);"
.br
.BI "extern int " numa_exit_on_error ;
.SH DESCRIPTION
The
.I libnuma 
library offers a simple programming interface to the 
NUMA (Non Uniform Memory Access)
policy supported by the 
Linux kernel. On a NUMA architecture some
memory areas have different latency or bandwidth than others.

Available policies are 
page interleaving (i.e., allocate in a round-robin fashion from all, 
or a subset, of the nodes on the system), 
preferred node allocation (i.e., preferably allocate on a particular node), 
local allocation (i.e., allocate on the node on which 
the thread is currently executing),
or allocation only on specific nodes (i.e., allocate on
some subset of the available nodes).
It is also possible to bind threads to specific nodes. 

Numa memory allocation policy is a per-thread attribute, but is
inherited by children. 

For setting a specific policy globally for all memory allocations
in a process and its children it is easiest
to start it with the 
.BR numactl (8)
utility. For more finegrained policy inside an application this library
can be used.

All numa memory allocation policy only takes effect when a page is actually
faulted into the address space of a process by accessing it. The 
.B numa_alloc_*
functions take care of this automatically.

A 
.I node 
is defined as an area where all memory has the same speed as seen from 
a particular CPU. A node can contain multiple CPUs. Caches are ignored for this definition. 

This library is only concerned about nodes and their memory and does not deal 
with individual CPUs inside these nodes
(except for 
.I numa_node_to_cpus
)

Before any other calls in this library can be used
.BR numa_available ()
must be called. If it returns \-1, all other functions in this
library are undefined.

.BR numa_max_node ()
returns the highest node number available on the current system. If a node
number or a node mask with a bit set above the value returned by this function
is passed to a 
.I libnuma
function, the result is undefined. 
    
.BR numa_node_size ()
returns the memory size of a node. If the argument
.I freep
is not NULL, it used to return the amount of free memory on the node.
On error it returns \-1.
.BR numa_node_size64 ()
works the same as 
.BR numa_node_size ()
except that it returns values as 
.I long long 
instead of 
.IR long .
This is useful on 32-bit architectures with large nodes.

Some of these functions accept or return a 
.IR nodemask .
A nodemask has type 
.IR nodemask_t .
It is an abstract bitmap type containing a bit set of nodes. 
The maximum node number depends 
on the architecture, but is not larger than
.BR numa_max_node ().
What happens in 
.I libnuma
calls when bits above 
.BR numa_max_node ()
are passed is undefined.
A 
.I nodemask_t 
should only be manipulated with the
.BR nodemask_zero (),
.BR nodemask_clr (),
.BR nodemask_isset (),
and
.BR nodemask_set ()
functions.  
.BR nodemask_zero ()
clears a 
.IR nodemask_t .
.BR nodemask_isset ()
returns true if 
.I node
is set in the passed
.IR nodemask .
.BR nodemask_clr ()
clears 
.I node
in 
.IR nodemask .
.BR nodemask_set ()
sets 
.I node
in 
.IR nodemask .
The predefined variable 
.I numa_all_nodes
has all available nodes set;
.I numa_no_nodes
is the empty set.
.BR nodemask_equal ()
returns non-zero if its two nodeset arguments are equal.

.BR numa_preferred ()
returns the preferred node of the current thread. 
This is the node on which the kernel preferably
allocates memory, unless some other policy overrides this.

.BR numa_set_interleave_mask ()
sets the memory interleave mask for the current thread to 
.IR nodemask .
All new memory allocations
are page interleaved over all nodes in the interleave mask. Interleaving
can be turned off again by passing an empty mask
.RI ( numa_no_nodes ).
The page interleaving only occurs on the actual page fault that puts a new
page into the current address space. It is also only a hint: the kernel
will fall back to other nodes if no memory is available on the interleave
target. This is a low level
function, it may be more convenient to use the higher level functions like
.BR numa_alloc_interleaved ()
or
.BR numa_alloc_interleaved_subset ().

.BR numa_get_interleave_mask ()
returns the current interleave mask. 

.BR numa_bind ()
binds the current thread and its children to the nodes 
specified in 
.IR nodemask .
They will only run on the CPUs of the specified nodes and only be able to allocate
memory from them.
This function is equivalent to calling
.\" FIXME checkme
.I numa_run_on_node_mask(nodemask)
followed by
.IR numa_set_membind(nodemask) .
If threads should be bound to individual CPUs inside nodes
consider using
.I numa_node_to_cpus
and the
.I sched_setaffinity(2)
syscall.


.BR numa_set_preferred ()
sets the preferred node for the current thread to
.IR node .
The preferred node is the node on which memory is 
preferably allocated before falling back to other nodes. 
The default is to use the node on which the process is currently running
(local policy). Passing a \-1 argument is equivalent to
.BR numa_set_localalloc ().

.BR numa_set_localalloc ()
sets a local memory allocation policy for the calling thread.
Memory is preferably allocated on the node on which the thread is 
currently running.

.BR numa_set_membind ()
sets the memory allocation mask.
The thread will only allocate memory from the nodes set in 
.IR nodemask .
Passing an argument of
.I numa_no_nodes
or
.I numa_all_nodes
turns off memory binding to specific nodes. 

.BR numa_get_membind ()
returns the mask of nodes from which memory can currently be allocated.
If the returned mask is equal to 
.I numa_no_nodes
or
.IR numa_all_nodes ,
then all nodes are available for memory allocation.

.BR numa_alloc_interleaved ()
allocates 
.I size
bytes of memory page interleaved on all nodes. This function is relatively slow
and should only be used for large areas consisting of multiple pages. The 
interleaving works at page level and will only show an effect when the 
area is large. 
The allocated memory must be freed with
.BR numa_free ().
On error, NULL is returned. 

.BR numa_alloc_interleaved_subset ()
is like
.BR numa_alloc_interleaved ()
except that it also accepts a mask of the nodes to interleave on.
On error, NULL is returned. 

.BR numa_alloc_onnode ()
allocates memory on a specific node. This function is relatively slow
and allocations are rounded up to the system page size. 
The memory must be freed
with
.BR numa_free ().
On errors NULL is returned. 

.BR numa_alloc_local ()
allocates
.I size
bytes of memory on the local node. This function is relatively slow
and allocations are rounded up to the system page size. 
The memory must be freed
with 
.BR numa_free ().
On errors NULL is returned. 

.BR numa_alloc ()
allocates
.I size 
bytes of memory with the current NUMA policy.  This function is relatively slow
and allocations are rounded up to the system page size. 
The memory must be freed
with 
.BR numa_free ().
On errors NULL is returned. 

.BR numa_free ()
frees 
.I size
bytes of memory starting at 
.IR start ,
allocated by the 
.B numa_alloc_* 
functions above.

.BR numa_run_on_node ()
runs the current thread and its children 
on a specific node. They will not migrate to CPUs of
other nodes until the node affinity is reset with a new call to
.BR numa_run_on_node_mask ().
Passing \-1
permits the kernel to schedule on all nodes again.
On success, 0 is returned; on error \-1 is returned, and
.I errno
is set to indicate the error.

.BR numa_run_on_node_mask ()
runs the current thread and its children only on nodes specified in 
.IR nodemask .
They will not migrate to CPUs of
other nodes until the node affinity is reset with a new call to
.BR numa_run_on_node_mask ().
Passing 
.I numa_all_nodes
permits the kernel to schedule on all nodes again.
On success, 0 is returned; on error \-1 is returned, and
.I errno
is set to indicate the error.

.BR numa_get_run_node_mask ()
returns the mask of nodes that the current thread is allowed to run on.

.BR numa_interleave_memory ()
interleaves
.I size 
bytes of memory page by page from 
.I start 
on nodes
.IR nodemask .
This is a lower level function to interleave not yet faulted in but  allocated 
memory. Not yet faulted in means the memory is allocated using 
.BR mmap (2)
or
.BR shmat (2),
but has not been accessed by the current process yet. The memory is page
interleaved to all nodes specified in 
.IR nodemask . 
Normally 
.BR numa_alloc_interleaved ()
should be used for private memory instead, but this function is useful to 
handle shared memory areas. To be useful the memory area should be 
several megabytes at least (or tens of megabytes of hugetlbfs mappings)
If the
.BR numa_set_strict ()
flag is true then the operation will cause a numa_error if there were already
pages in the mapping that do not follow the policy.

.BR numa_tonode_memory ()
put memory on a specific node. The constraints described for 
.BR numa_interleave_memory ()
apply here too.

.BR numa_tonodemask_memory ()
put memory on a specific set of nodes. The constraints described for 
.BR numa_interleave_memory ()
apply here too. 

.BR numa_setlocal_memory ()
locates memory on the current node. The constraints described for 
.BR numa_interleave_memory ()
apply here too.

.BR numa_police_memory ()
locates memory with the current NUMA policy. The constraints described for 
.BR numa_interleave_memory ()
apply here too.

.BR numa_node_to_cpus ()
converts a node number to a bitmask of CPUs. The user must pass a long enough
buffer. If the buffer is not long enough 
.I errno
will be set to
.I ERANGE
and \-1 returned. On success 0 is returned.

.BR numa_set_bind_policy ()
specifies whether calls that bind memory to a specific node should 
use the preferred policy or a strict policy. 
The preferred policy allows the kernel
to allocate memory on other nodes when there isn't enough free
on the target node. strict will fail the allocation in that case.
Setting the argument to specifies strict, 0 preferred.
Note that specifying more than one node non strict may only use
the first node in some kernel versions.

.BR numa_set_strict ()
sets a flag that says whether the functions allocating on specific
nodes should use use a strict policy. Strict means the allocation 
will fail if the memory cannot be allocated on the target node.
Default operation is to fall back to other nodes.
This doesn't apply to interleave and default.

.BR numa_distance ()
reports the distance in the machine topology between two nodes.
The factors are a multiple of 10. It returns 0 when the distance
cannot be determined. A node has distance 10 to itself.
Reporting the distance requires a Linux
kernel version of 
.I 2.6.10 
or newer.

.BR numa_error ()
is a weak internal 
.I libnuma 
function that can be overridden by the
user program. 
This function is called with a
.I char *
argument when a
.I libnuma
function fails.
Overriding the weak library definition
makes it possible to specify a different error handling strategy
when a 
.I libnuma
function fails. It does not affect
.BR numa_available ().

The
.BR num_error ()
function defined in
.I libnuma
prints an error on
.I stderr 
and terminates
the program if
.I numa_exit_on_error
is set to a non-zero value. 
The default value of
.I numa_exit_on_error
is zero.

.BR numa_warn ()
is a weak internal 
.I libnuma 
function that can be also overridden
by the user program.  
It is called to warn the user when a 
.I libnuma
function encounters a non-fatal error.
The default implementation
prints a warning to 
.IR stderr .

The first argument is a unique
number identifying each warning. After that there is a 
.BR printf (3)-style 
format string and a variable number of arguments.

.SH THREAD SAFETY
.I numa_set_bind_policy
and
.I numa_exit_on_error
are process global. The other calls are thread safe. 

Memory policy set for memory areas is shared by all threads 
of the process.  Memory policy is also
shared by other processes mapping the same memory using 
.I shmat(2) 
or 
.I mmap(2)
from shmfs/hugetlbfs.  It is not shared for
disk backed file mappings right now although that may change in the future.

.SH COPYRIGHT
Copyright 2002, 2004, Andi Kleen, SuSE Labs.
.I libnuma 
is under the GNU Lesser General Public License, v2.1.

.SH SEE ALSO
.BR get_mempolicy (2),
.BR getpagesize (2),
.BR mbind (2),
.BR mmap (2),
.BR set_mempolicy (2),
.BR shmat (2),
.BR numactl (8),
.BR sched_setaffinity (2)
